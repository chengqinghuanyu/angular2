{"version":3,"sources":["../source/parse.js"],"names":["parse","normalize","replace_characters","is_viable_phone_number","extract_formatted_phone_number","parse_phone_number","parse_phone_number_and_country_phone_code","strip_national_prefix","find_country_code","PLUS_CHARS","VALID_DIGITS","DASHES","SLASHES","DOTS","WHITESPACE","BRACKETS","TILDES","VALID_PUNCTUATION","MIN_LENGTH_PHONE_NUMBER_PATTERN","MIN_LENGTH_FOR_NSN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","RegExp","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","LEADING_PLUS_CHARS_PATTERN","DIGIT_MAPPINGS","MAX_LENGTH_COUNTRY_CODE","MAX_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","default_options","country","first_argument","second_argument","third_argument","sort_out_arguments","text","options","metadata","default","countries","Error","restrict","formatted_phone_number","country_phone_code","number","country_metadata","is_international","national_number","did_have_national_prefix","length","national_number_rule","phone","replacements","replaced","character","replacement","toUpperCase","undefined","starts_at","search","slice","replace","test","i","country_phone_code_to_countries","national_prefix_for_parsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","any_groups_were_captured","national_prefix_transform_rule","national_phone_number","possible_countries","country_code","restrict_to_country"],"mappings":"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","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport { matches_entirely } from './common'\n\nimport\n{\n\tget_phone_code,\n\tget_national_number_pattern,\n\tget_national_prefix_for_parsing,\n\tget_national_prefix_transform_rule,\n\tget_leading_digits,\n\tget_metadata_by_country_phone_code,\n\tget_formats,\n\t// get_format_national_prefix_is_mandatory_when_formatting\n}\nfrom './metadata'\n\nimport\n{\n\tchoose_format_for_number\n}\nfrom './format'\n\nimport get_number_type from './get number type'\n\nexport const PLUS_CHARS = '+\\uFF0B'\n\n// Digits accepted in phone numbers\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\n\n// `DASHES` will be right after the opening square bracket of the \"character class\"\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\nconst SLASHES = '\\uFF0F/'\nconst DOTS = '\\uFF0E.'\nconst WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\n\n// Regular expression of acceptable punctuation found in phone numbers. This\n// excludes punctuation found as a leading character only. This consists of dash\n// characters, white space characters, full stops, slashes, square brackets,\n// parentheses and tildes. Full-width variants are also present.\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\n\n//  Regular expression of viable phone numbers. This is location independent.\n//  Checks we have at least three leading digits, and only valid punctuation,\n//  alpha characters and digits in the phone number. Does not include extension\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\n//  used as a placeholder for carrier codes, for example in Brazilian phone\n//  numbers. We also allow multiple '+' characters at the start.\n//\n//  Corresponds to the following:\n//  [digits]{minLengthNsn}|\n//  plus_sign*\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\n//\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\n//  The second expression restricts the number of digits to three or more, but\n//  then allows them to be in international form, and to have alpha-characters\n//  and punctuation. We split up the two reg-exes here and combine them when\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\n//  with ^ and append $ to each branch.\n//\n//  Note VALID_PUNCTUATION starts with a -, so must be the first in the range.\n//  (wtf did they mean by saying that; probably nothing)\n//\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\n//\n// And this is the second reg-exp:\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\n//\nconst VALID_PHONE_NUMBER =\n\t\t'[' + PLUS_CHARS + ']{0,1}' +\n\t\t'(?:' +\n\t\t\t'[' + VALID_PUNCTUATION + ']*' +\n\t\t\t'[' + VALID_DIGITS + ']' +\n\t\t'){3,}' +\n\t\t'[' +\n\t\t\tVALID_PUNCTUATION +\n\t\t\tVALID_DIGITS +\n\t\t']*'\n\n// The combined regular expression for valid phone numbers:\n//\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\n(\n\t// Either a short two-digit-only phone number\n\t'^' +\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\n\t'$' +\n\t'|' +\n\t// Or a longer fully parsed phone number (min 3 characters)\n\t'^' +\n\t\tVALID_PHONE_NUMBER +\n\t\t// screw phone number extensions\n\t\t// '(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\n\t'$'\n,\n'i')\n\n// This consists of the plus symbol, digits, and arabic-indic digits.\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\n\n// Regular expression of trailing characters that we want to remove.\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\n\nconst LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')\n\n// These mappings map a character (key) to a specific digit that should\n// replace it for normalization purposes. Non-European digits that\n// may be used in phone numbers are mapped to a European equivalent.\nconst DIGIT_MAPPINGS =\n{\n\t'0': '0',\n\t'1': '1',\n\t'2': '2',\n\t'3': '3',\n\t'4': '4',\n\t'5': '5',\n\t'6': '6',\n\t'7': '7',\n\t'8': '8',\n\t'9': '9',\n\t'\\uFF10': '0', // Fullwidth digit 0\n\t'\\uFF11': '1', // Fullwidth digit 1\n\t'\\uFF12': '2', // Fullwidth digit 2\n\t'\\uFF13': '3', // Fullwidth digit 3\n\t'\\uFF14': '4', // Fullwidth digit 4\n\t'\\uFF15': '5', // Fullwidth digit 5\n\t'\\uFF16': '6', // Fullwidth digit 6\n\t'\\uFF17': '7', // Fullwidth digit 7\n\t'\\uFF18': '8', // Fullwidth digit 8\n\t'\\uFF19': '9', // Fullwidth digit 9\n\t'\\u0660': '0', // Arabic-indic digit 0\n\t'\\u0661': '1', // Arabic-indic digit 1\n\t'\\u0662': '2', // Arabic-indic digit 2\n\t'\\u0663': '3', // Arabic-indic digit 3\n\t'\\u0664': '4', // Arabic-indic digit 4\n\t'\\u0665': '5', // Arabic-indic digit 5\n\t'\\u0666': '6', // Arabic-indic digit 6\n\t'\\u0667': '7', // Arabic-indic digit 7\n\t'\\u0668': '8', // Arabic-indic digit 8\n\t'\\u0669': '9', // Arabic-indic digit 9\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\n}\n\n// The maximum length of the country calling code.\nconst MAX_LENGTH_COUNTRY_CODE = 3\n\n// The minimum length of the national significant number.\nconst MIN_LENGTH_FOR_NSN = 2\n\n// The ITU says the maximum length should be 15,\n// but one can find longer numbers in Germany.\nconst MAX_LENGTH_FOR_NSN = 17\n\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nconst MAX_INPUT_STRING_LENGTH = 250\n\nconst default_options =\n{\n\tcountry: {}\n}\n\n// `options`:\n//  {\n//    country:\n//    {\n//      restrict - (a two-letter country code)\n//                 the phone number must be in this country\n//\n//      default - (a two-letter country code)\n//                default country to use for phone number parsing and validation\n//                (if no country code could be derived from the phone number)\n//    }\n//  }\n//\n// Returns `{ country, number }`\n//\n// Example use cases:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\nexport default function parse(first_argument, second_argument, third_argument)\n{\n\tlet { text, options, metadata } = sort_out_arguments(first_argument, second_argument, third_argument)\n\n\tif (!options)\n\t{\n\t\toptions = { ...default_options }\n\t}\n\n\t// Validate country codes\n\n\t// Validate `default` country\n\tif (options.country.default && !metadata.countries[options.country.default])\n\t{\n\t\tthrow new Error(`Unknown country code: ${options.country.default}`)\n\t}\n\n\t// Validate `restrict` country\n\tif (options.country.restrict && !metadata.countries[options.country.restrict])\n\t{\n\t\tthrow new Error(`Unknown country code: ${options.country.restrict}`)\n\t}\n\n\t// Parse the phone number\n\n\tconst formatted_phone_number = extract_formatted_phone_number(text)\n\n\t// If the phone number is not viable, then abort.\n\tif (!is_viable_phone_number(formatted_phone_number))\n\t{\n\t\treturn {}\n\t}\n\n\tlet { country_phone_code, number } = parse_phone_number_and_country_phone_code(formatted_phone_number, metadata)\n\n\t// Maybe invalid country phone code encountered\n\tif (!number)\n\t{\n\t\treturn {}\n\t}\n\n\tlet country\n\tlet country_metadata\n\n\t// Whether the phone number is formatted as an international phone number\n\tlet is_international = false\n\n\tif (country_phone_code)\n\t{\n\t\tis_international = true\n\n\t\t// Check country restriction\n\t\tif (options.country.restrict &&\n\t\t\tcountry_phone_code !== get_phone_code(metadata.countries[options.country.restrict]))\n\t\t{\n\t\t\treturn {}\n\t\t}\n\n\t\t// Formatting information for regions which share\n\t\t// a country calling code is contained by only one region\n\t\t// for performance reasons. For example, for NANPA region\n\t\t// (\"North American Numbering Plan Administration\",\n\t\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\n\t\t// it will be contained in the metadata for `US`.\n\t\tcountry_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata)\n\n\t\t// `country` will be set later,\n\t\t// because, for example, for NANPA countries\n\t\t// there are several countries corresponding\n\t\t// to the same `1` country phone code.\n\t\t// Therefore, to reliably determine the exact country,\n\t\t// national (significant) number should be parsed first.\n\t}\n\telse if (options.country.restrict || options.country.default)\n\t{\n\t\tcountry = options.country.restrict || options.country.default\n\t\tcountry_metadata = metadata.countries[country]\n\n\t\tnumber = normalize(text)\n\t}\n\n\tif (!country_metadata)\n\t{\n\t\treturn {}\n\t}\n\n\tconst national_number = strip_national_prefix(number, country_metadata)\n\n\tconst did_have_national_prefix = national_number !== number\n\n\t// https://github.com/halt-hammerzeit/libphonenumber-js/issues/67\n\t// if (!is_international && !did_have_national_prefix &&\n\t// \t\tis_national_prefix_required(national_number, country_metadata))\n\t// {\n\t// \treturn {}\n\t// }\n\n\t// Sometimes there are several countries\n\t// corresponding to the same country phone code\n\t// (e.g. NANPA countries all having `1` country phone code).\n\t// Therefore, to reliably determine the exact country,\n\t// national (significant) number should have been parsed first.\n\t//\n\tif (!country)\n\t{\n\t\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\n\t\t// get their countries populated with the full set of\n\t\t// \"phone number type\" regular expressions.\n\t\tcountry = find_country_code(country_phone_code, national_number, metadata)\n\n\t\t// Just in case there appears to be a bug in Google's metadata\n\t\t// and the exact country could not be extracted from the phone number.\n\t\t/* istanbul ignore if */\n\t\tif (!country)\n\t\t{\n\t\t\treturn {}\n\t\t}\n\n\t\t// Update metadata to be for this specific country\n\t\tcountry_metadata = metadata.countries[country]\n\t}\n\n\t// Validate national (significant) number length.\n\t//\n\t// A sidenote:\n\t//\n\t// They say that sometimes national (significant) numbers\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n\t// Such numbers will just be discarded.\n\t//\n\tif (national_number.length > MAX_LENGTH_FOR_NSN)\n\t{\n\t\treturn {}\n\t}\n\n\t// National number pattern is different for each country,\n\t// even for those ones which are part of the \"NANPA\" group.\n\tconst national_number_rule = new RegExp(get_national_number_pattern(country_metadata))\n\n\t// Check if national phone number pattern matches the number\n\tif (!matches_entirely(national_number, national_number_rule))\n\t{\n\t\treturn {}\n\t}\n\n\treturn { country, phone: national_number }\n}\n\n// Normalizes a string of characters representing a phone number.\n// This converts wide-ascii and arabic-indic numerals to European numerals,\n// and strips punctuation and alpha characters.\nexport function normalize(number)\n{\n\treturn replace_characters(number, DIGIT_MAPPINGS)\n}\n\n// For any character not being part of `replacements`\n// it is removed from the phone number.\nexport function replace_characters(text, replacements)\n{\n\tlet replaced = ''\n\n\tfor (let character of text)\n\t{\n\t\tconst replacement = replacements[character.toUpperCase()]\n\n\t\tif (replacement !== undefined)\n\t\t{\n\t\t\treplaced += replacement\n\t\t}\n\t}\n\n\treturn replaced\n}\n\n// Checks to see if the string of characters could possibly be a phone number at\n// all. At the moment, checks to see that the string begins with at least 2\n// digits, ignoring any punctuation commonly found in phone numbers. This method\n// does not require the number to be normalized in advance - but does assume\n// that leading non-number symbols have been removed, such as by the method\n// `extract_possible_number`.\n//\nexport function is_viable_phone_number(number)\n{\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\n\t\tmatches_entirely(number, VALID_PHONE_NUMBER_PATTERN)\n}\n\nexport function extract_formatted_phone_number(text)\n{\n\tif (!text || text.length > MAX_INPUT_STRING_LENGTH)\n\t{\n\t\treturn ''\n\t}\n\n\t// Attempt to extract a possible number from the string passed in\n\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\n\n\tif (starts_at < 0)\n\t{\n\t\treturn ''\n\t}\n\n\treturn text\n\t\t// Trim everything to the left of the phone number\n\t\t.slice(starts_at)\n\t\t// Remove trailing non-numerical characters\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\n}\n\n// Parses a formatted phone number.\nexport function parse_phone_number(number)\n{\n\tif (!number)\n\t{\n\t\treturn ''\n\t}\n\n\tconst is_international = LEADING_PLUS_CHARS_PATTERN.test(number)\n\n\t// Remove non-digits\n\t// (and strip the possible leading '+')\n\tnumber = normalize(number)\n\n\tif (is_international)\n\t{\n\t\treturn `+${number}`\n\t}\n\n\treturn number\n}\n\n// Parses a formatted phone number\n// and returns `{ country_phone_code, number }`\n// where `number` is the national (significant) phone number.\n//\n// (aka `maybeExtractCountryPhoneCode`)\n//\nexport function parse_phone_number_and_country_phone_code(number, metadata)\n{\n\tnumber = parse_phone_number(number)\n\n\tif (!number)\n\t{\n\t\treturn {}\n\t}\n\n\t// If this is not an international phone number,\n\t// then don't extract country phone code.\n\tif (number[0] !== '+')\n\t{\n\t\treturn { number }\n\t}\n\n\t// Strip the leading '+' sign\n\tnumber = number.slice(1)\n\n\t// Fast abortion: country codes do not begin with a '0'\n\tif (number[0] === '0')\n\t{\n\t\treturn {}\n\t}\n\n\t// The thing with country phone codes\n\t// is that they are orthogonal to each other\n\t// i.e. there's no such country phone code A\n\t// for which country phone code B exists\n\t// where B starts with A.\n\t// Therefore, while scanning digits,\n\t// if a valid country code is found,\n\t// that means that it is the country code.\n\t//\n\tlet i = 1\n\twhile (i <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\n\t{\n\t\tconst country_phone_code = number.slice(0, i)\n\n\t\tif (metadata.country_phone_code_to_countries[country_phone_code])\n\t\t{\n\t\t\treturn { country_phone_code, number: number.slice(i) }\n\t\t}\n\n\t\ti++\n\t}\n\n\treturn {}\n}\n\n// Strips any national prefix (such as 0, 1) present in the number provided\nexport function strip_national_prefix(number, country_metadata)\n{\n\tconst national_prefix_for_parsing = get_national_prefix_for_parsing(country_metadata)\n\n\tif (!number || !national_prefix_for_parsing)\n\t{\n\t\treturn number\n\t}\n\n\t// Attempt to parse the first digits as a national prefix\n\tconst national_prefix_pattern = new RegExp('^(?:' + national_prefix_for_parsing + ')')\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\n\n\t// If no national prefix is present in the phone number,\n\t// but if the national prefix is optional for this country,\n\t// then consider this phone number valid.\n\t//\n\t// Google's reference `libphonenumber` implementation\n\t// wouldn't recognize such phone numbers as valid,\n\t// but I think it would perfectly make sense\n\t// to consider such phone numbers as valid\n\t// because if a national phone number was originally\n\t// formatted without the national prefix\n\t// then it must be parseable back into the original national number.\n\t// In other words, `parse(format(number))`\n\t// must always be equal to `number`.\n\t//\n\tif (!national_prefix_matcher)\n\t{\n\t\treturn number\n\t}\n\n\n\tlet national_significant_number\n\n\t// `national_prefix_for_parsing` capturing groups\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\n\tconst any_groups_were_captured = national_prefix_matcher[national_prefix_matcher.length - 1]\n\tconst national_prefix_transform_rule = get_national_prefix_transform_rule(country_metadata)\n\n\t// If the national number tranformation is needed then do it\n\tif (national_prefix_transform_rule && any_groups_were_captured)\n\t{\n\t\tnational_significant_number = number.replace(national_prefix_pattern, national_prefix_transform_rule)\n\t}\n\t// Else, no transformation is necessary,\n\t// and just strip the national prefix.\n\telse\n\t{\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\n\t}\n\n\t// Verify the parsed national (significant) number for this country\n\tconst national_number_rule = new RegExp(get_national_number_pattern(country_metadata))\n\n\t// If the original number (before stripping national prefix) was viable,\n\t// and the resultant number is not, then prefer the original phone number.\n\t// This is because for some countries (e.g. Russia) the same digit could be both\n\t// a national prefix and a leading digit of a valid national phone number,\n\t// like `8` is the national prefix for Russia and both\n\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\tif (matches_entirely(number, national_number_rule) &&\n\t\t\t!matches_entirely(national_significant_number, national_number_rule))\n\t{\n\t\treturn number\n\t}\n\n\t// Return the parsed national (significant) number\n   return national_significant_number\n}\n\nexport function find_country_code(country_phone_code, national_phone_number, metadata)\n{\n\t// Is always non-empty, because `country_phone_code` is always valid\n\tconst possible_countries = metadata.country_phone_code_to_countries[country_phone_code]\n\n\t// If there's just one country corresponding to the country code,\n\t// then just return it, without further phone number digits validation.\n\tif (possible_countries.length === 1)\n\t{\n\t\treturn possible_countries[0]\n\t}\n\n\tfor (let country_code of possible_countries)\n\t{\n\t\tconst country = metadata.countries[country_code]\n\n\t\t// Leading digits check would be the simplest one\n\t\tif (get_leading_digits(country))\n\t\t{\n\t\t\tif (national_phone_number &&\n\t\t\t\tnational_phone_number.search(get_leading_digits(country)) === 0)\n\t\t\t{\n\t\t\t\treturn country_code\n\t\t\t}\n\t\t}\n\t\t// Else perform full validation with all of those bulky\n\t\t// fixed-line/mobile/etc regular expressions.\n\t\telse if (get_number_type({ phone: national_phone_number, country: country_code }, metadata))\n\t\t{\n\t\t\treturn country_code\n\t\t}\n\t}\n}\n\n// export function is_national_prefix_required(national_number, country_metadata)\n// {\n// \tconst format = choose_format_for_number(get_formats(country_metadata), national_number)\n//\n// \tif (format)\n// \t{\n// \t\treturn get_format_national_prefix_is_mandatory_when_formatting(format, country_metadata)\n// \t}\n// }\n\n// Sort out arguments\nfunction sort_out_arguments(first_argument, second_argument, third_argument)\n{\n\tlet text\n\tlet options\n\tlet metadata\n\n\tif (typeof first_argument === 'string')\n\t{\n\t\ttext = first_argument\n\t}\n\n\t// Covert `resrict` country to an `options` object\n\tif (typeof second_argument === 'string')\n\t{\n\t\tconst restrict_to_country = second_argument\n\n\t\toptions =\n\t\t{\n\t\t\t...default_options,\n\n\t\t\tcountry:\n\t\t\t{\n\t\t\t\trestrict: restrict_to_country\n\t\t\t}\n\t\t}\n\n\t\tmetadata = third_argument\n\t}\n\telse\n\t{\n\t\t// Differentiate `metadata` from `options`\n\t\tif (second_argument && second_argument.countries)\n\t\t{\n\t\t\tmetadata = second_argument\n\t\t}\n\t\telse\n\t\t{\n\t\t\toptions  = second_argument\n\t\t\tmetadata = third_argument\n\t\t}\n\t}\n\n\t// Sanity check\n\tif (!metadata)\n\t{\n\t\tthrow new Error('Metadata not passed')\n\t}\n\n\treturn { text, options, metadata }\n}"]}